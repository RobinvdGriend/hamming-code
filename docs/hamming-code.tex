\documentclass[a4paper]{article}
\usepackage[dutch]{babel}
\usepackage{mathtools}
\usepackage{listings}

\lstset{language=Python}

\begin{document}
\title{Hamming-code in Python 3.6}
\author{Robin van de Griend, Thomas Koopman, Tim Waroux}
\maketitle

\section{Taakverdeling}
Voor het maken van het algoritme hadden we niet echt een taakverdeling gemaakt. Naarmate we bezig waren kwamen we er wel achter dat het handig was dat Robin bleef werken aan het strconv algoritme, en dat Thomas en Tim bezig waren met de andere onderdelen van de code, en hebben samen vooral veel bugs uit het systeem gehaald.

\section{Ontwerp van de code}
We hebben er voor gekozen om gebruik te maken van verschillende modules, we hebben voor belangrijke functies een apart bestand aangemaakt. Dit is beter voor de leesbaarheid en maakt het makkelijker om te werken in de code. Hieronder volgt een toelichting voor de verschillende modules.

\subsection{matrix.py}
	Om te beginnen met het programmeren van de Hammingcode, hebben we ervoor gekozen om eerst een klasse Matrix te definieren. Dit staat eveneens aangegeven in de opdracht die we gevolgd hebben. Hier is al onze code opgebasseerd omdat we bij onze hammingcode gebruik maken van de matrixvermenigvuldiging.

\subsection{strconv.py}
	Onze stringconvert bestand is van essentieel belang voor onze hammingcode. De functies die gedefinieerd staan in stringconvert zorgen ervoor dat een string, met name de teskt die mensen willen versturen of opslaan, omzet naar een lijst met matrices. Hierdoor kunnen we ze gebruiken in het Hamming bestand, waar onze Hammingcode wordt uitgevoerd.

\subsection{hamming.py}
	In dit bestand staat ons algoritme voor de hammingcode. Om te beginnen staat er in de bestand het belangrijkste gedefinieerd van onze hele code. Namelijk de generator en pariteitcheck matrix. In dit bestand staan verder de functies waarmee we pariteit kunnen toevoegen aan bits, eventuele 1 bits fouten kunnen vinden en als deze er zijn herstellen, verder is er nog een functie waarmee we de pariteit van de bits kunnen verwijderen om later in interface.py de string van 1-en 0'en terug te vertalen naar iets wat wij kunnen lezen.

\subsection{errormaker.py}
	Dit is een klein bestand waarin we 2 functies hebben gedefinieerd: Errormaker, de functie waarmee we random 1 bits fouten kunnen maken in een lijst met vectoren waar pariteitbits aaantoegevoegd zijn, en Errormakerstring de functie waar we in een string van 1-en 0'en random 1 bits fouten kunnen maken.

\subsection{interface.py}
	Dit is het bestand dat de gebruiker van ons programma moet opstarten. In dit bestand komen alle functies van de andere bestanden samen en worden ze samengebruikt om berichten te encoderen en decoderen, en bij het decoderen eventueel een aantal 1 bits fouten toe tevoegen om te laten zien dat het programma deze fouten kan herstellen.

\section{Complexiteit}
We drukken de complexiteit uit in de lengte van de boodschap \(n\). Of dit in bits of in tekens of in matrices is, maakt niet uit omdat elk teken 8 bits is, en elk teken 1 matrix is. Dus in grote O notatie maakt dit niet uit.

encodeentiremessage is O(n) want message is een lijst van n matrices (elk karakter is 1 matrix), en je loopt 1 keer door de lijst heen, en voert elke keer een constant aantal operaties uit. Een lege lijst new\_message maken en dit returnen hangt niet van n af en is dus constant.

Alle functies behalve $decoderen$, $encoderen$, $binary_to_codelist$, $codelist_to_str$, $str_to_codelist$, $encodeentiremessage$, $repairentiremessage$ en $destroyallparitybits$ krijgen geen boodschap of lijst met matrices als input, dus die zijn O(1). 

\subsection{destroyallparitybits}

Er wordt $n$ keer $destroyparitybits$ aangeroepen, die O(1) is. De rest is O(1), dus de complexiteit is O(n).

\subsection{encodeentiremessage}

Dit is ook O(n), analoog aan $destroyallparitybits$.

\subsection{repairentiremessage}

Dit is ook O(n), analoog aan $destroyallparitybits$.

\subsection{binary\_to\_codelist}

De lijst bytelist aanmaken is O(n). Daarna komen er twee loops die O(n) keer worden aangeroepen, waarin O(1) dingen gebeuren, dus dit algoritme is O(n).

\subsection{codelist\_to\_str}

De lijst codepairs aanmaken is O(n), de loop eronder wordt $n$ keer uitgevoerd en er gebeuren O(1) dingen in, dus dit is ook O(n). Dit algoritme is dus O(n).

\subsection{str\_to\_codelist}

Er wordt een bytearray gemaakt en opgeslagen, dit is O(n). Dan is er een loop van lengte $n$ waarin allerlei O(1) operaties worden uitgevoerd. Dit is dus een O(n) algorithme. 


Het geval destroyallparitybits is analoog.

\subsection{encoderen}

Alles is O(1) behalve het aanroepen van str\_to\_codelist en encodeentiremessage, die beiden O(n) zijn, dus dit is O(n).

\subsection{decoderen}

Alles is O(1) behalve het aanroepen van binary\_to\_codelist, repairentiremessage, destroyallparitybits en codelist\_to\_str die allen O(n) zijn, dus dit is O(n).

\section{Verbeterpunten en mogelijke uitbreidingen van de code}
De Matrix klasse hebben is een zelfgeschreven library waarvan de interface nog verbetert zou kunnen worden. Zo komt het vaak voor in de code waar we lijst-operaties willen uitvoeren op vectoren, een matrix met 1 rij. Op het moment moet je dan de waarden van de matrix opvragen en opslaan als lijst om vervolgens weer opnieuw een matrix aan te moeten maken met de nieuwe lijst van waarden. Zoals de interface nu is geschreven ontstaan er situaties als deze:
\begin{lstlisting}
	code_pairs = [(codelist[i].values[0], 
		codelist[i + 1].values[0]) 
		for i in range(0, len(codelist) - 1, 2)]
\end{lstlisting}
Dit is een stukje code uit \texttt{strconv.py} waar we een lijst van matrices \texttt{codelist} uit willen pakken en voor elke matrix een lijst-operatie willen uitvoeren. In feite zijn maken we hier nergens gebruik van de Matrix-klasse maar toch staan onze codes opgeslagen in een matrix omdat we matrix-vermenigvuldiging gebruiken in het hamming-algoritme.

Veel beter zou het zijn om een externe library te gebruiken als numpy, waar matrices en vectoren een intuïtieve interface hebben. Ook is de code sneller omdat veel rekenintensieve functies in C zijn geïmplementeerd. Verder zou functionaliteit in \texttt{strconv.py} in de Matrix-klasse gebouwd kunnen worden. Het gaat immers om het omzetten van matrices naar andere objecttypes of vice versa. Op die manier houden we functionaliteit die bij matrices hoort bij elkaar.

We zouden Hamming-codes algemener kunnen implementeren. Een Hamming-code wordt volledig vastgelegd door zijn controle-matrix, de genererende matrix kan immers hieruit bepaald worden. We zouden een code kunnen schrijven die voor algemene (n,k,d)-Hamming codes de \(n \times d\) controle-matrix maakt en hieruit de genererende matrix vindt. Op deze manier hoeven we geen matrices expliciet te definiëren en kunnen we ze "as needed" genereren.

\end{document}
